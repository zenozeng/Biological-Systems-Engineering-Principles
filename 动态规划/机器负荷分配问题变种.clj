(ns machine.core
  (:require [clojure.math.numeric-tower :as math]))

;; 某种机器可以在高、低两种负荷下生产。高负荷生产条件
;; 下机器完好率为0.7,即如果年初有u台完好机器投入生产,则
;; 年末完好的机器数量为0.7u台。系数0.7称为完好率。年初投入
;; 高负荷运行的u台机器的年产量为8u吨。系数8称为单台产量。
;; 低负荷运行时,机器完好率为0.9,单台产量为5吨。设开始时
;; 有1000台完好机器,要制订五年计划,每年年初将完好的机器
;; 一部分分配到高负荷生产,剩下的机器分配到低负荷生产,使
;; 五年的总产量为最高。
;; 要求在第五年末(即第六年初)完好的机器数为500台。

;; 定义基本常量
(def 高负荷机器完好率 0.7)
(def 低负荷机器完好率 0.9)
(def 高负荷单台年产量 8)
(def 低负荷单台年产量 5)
(def 机器数量 1000)
(def 年数 5)
(def 最终剩余机器数 500)

;; 决策允许集合中可取的决策数量很大,
;; 一一列举计算量很大,
;; 不妨认为状态变量和决策变量都是连续的,得到最优解后,再取整

;; 定义模型
;; 阶段k: 运行年份 k = 1, 2, 3, 4, 5, 6 (k=1 => 第一年初)
;; 状态变量xk: 第k年初完好的机器数 k = 1, 2, 3, 4, 5, 6 (x6 第六年初的完好机器数)
;; 决策变量dk: 第k年投入高负荷运行的机器数
;; 状态转移方程: x(k+1) = 0.7dk + 0.9(xk - dk)
;; 决策允许集合: Dk(xk) = {dk | 0 <= dk <= xk}
;; 阶段指标: vk(xk, dk) = 8dk + 5(xk - dk)
;; 终端条件: x6 = 500

;; 500 = x6 = 0.7 * d5 + 0.9 * (x5 - d5)
;; d5 = 4.5 * x5 - 2500

;; 最终剩余机器数 = 高负荷机器完好率 * d5 + 低负荷机器完好率 * (x5 - d5)
;; (高负荷机器完好率 - 低负荷机器完好率) * d5 = 最终剩余机器数 - 低负荷机器完好率 * x5

;; f5(x5) = max{ 8 * d5 + 5 * (x5 - d5) }
;;        = max{ 3 * d5 + 5 * x5 }
;;        = 18.5 * x5 - 7500
;; f4(x4) = max{ 8 * d4 + 5 * (x4 - d4) + 18.5 * x5 - 7500 }

;; 则可见，相对于原题，这只是产生了一个偏差系数

;; 计算偏差系数

(def offset (* (- 高负荷单台年产量 低负荷单台年产量)
               (/ 最终剩余机器数 (- 高负荷机器完好率 低负荷机器完好率))))

(def init-weight (+ (* (- 高负荷单台年产量 低负荷单台年产量)
                       (/ (- 低负荷机器完好率)
                          (- 高负荷机器完好率 低负荷机器完好率)))
                    低负荷单台年产量))


(defn calc-weight
  "w_d 是 dn 的系数，w_x 是 xn 的系数，last-weight，比如对第五年则为第6年"
  [last-weight]
  (let [w [(+ (- 高负荷单台年产量
                 低负荷单台年产量)
              (* last-weight (- 高负荷机器完好率 低负荷机器完好率)))
           (+ 低负荷单台年产量 (* last-weight 低负荷机器完好率))]]
    (if (> (first w) 0)
      (apply + w)
      (last w))))

(defn get-weight [n]
  (nth (iterate calc-weight init-weight) (- n 1)))

(math/round (+ (* (get-weight 年数) 机器数量) offset))
